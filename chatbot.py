import os
import pandas as pd 
import logging
import streamlit as st
from langchain.agents import create_sql_agent
from langchain.agents.agent_toolkits import SQLDatabaseToolkit
from langchain_community.utilities import SQLDatabase
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from db_config import DB_CONFIG, COMPANY_NAME, COMPANY_DESCRIPTION  # Make sure DB_CONFIG is correctly set up
from database import db_manager

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database Configuration
db_host = st.secrets["DB_HOST"]
db_user = st.secrets["DB_USER"]
db_password = st.secrets["DB_PASSWORD"]
db_name = st.secrets["DB_NAME"]
db_port = st.secrets["DB_PORT"]

# OpenAI API Key
OPENAI_API_KEY = st.secrets["OPENAI_API_KEY"]

st.set_page_config(
    page_title=f"{COMPANY_NAME} AI Assistant",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded"
)

def initialize_session_state():
    """Initialize session state variables"""
    if 'messages' not in st.session_state:
        st.session_state.messages = []
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []
    if 'db_manager' not in st.session_state:
        st.session_state.db_manager = None
    if 'llm_chain' not in st.session_state:
        st.session_state.llm_chain = None


try:
    # Connect to the database
    db = SQLDatabase.from_uri(
        f"mysql+pymysql://{db_user}:{db_password}@{db_host}/{db_name}"
    )
    st.success("‚úÖ Database connected successfully.")
except Exception as e:
    st.error(f"‚ùå Error connecting to the database: {e}")


# Create the first LLM (Language Model) for classification
llm_classifier = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.8)

# Initialize the second LLM (general-purpose LLM)
llm_general = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.8)

# Initialize the third LLM for database queries
llm_database = ChatOpenAI(model="gpt-3.5-turbo", temperature=0.8)

# Create the SQL Database Toolkit for the agent
toolkit = SQLDatabaseToolkit(db=db, llm=llm_database)

# Create the first ChatPromptTemplate (for database query)
chat_prompt = ChatPromptTemplate.from_messages([
    ("system", "Prices are in INR. Please ensure that the response is in INR format. And for domain of tech and non-tech check domain column and if name is asked like machine learning or MBA check name in research_paper or assignment name column."),
    ("system", "You are a helpful assistant that can query databases and provide results in the requested format."),
    ("user", "{input}")
])

# Create the SQL Agent with the first LLM and the toolkit
agent_executor = create_sql_agent(
    llm=llm_database,
    toolkit=toolkit,
    verbose=True,
    handling_parsing_error=True
)

# Create the second ChatPromptTemplate (for elaborating the answer)
elaboration_prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful assistant that can elaborate on answers generated by query into proper format requested by user."),
    ("user", "Elaborate on the following answer: {input}")
])

general_prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a helpful assistant that help with educational stuff."),
    ("user", "{input}")
])

# Function to classify and route the query based on "general" or "database"
def classify_and_process_query(user_input):
    # Create the classification prompt template to decide if the query is general or database-related
    classify_prompt = ChatPromptTemplate.from_messages([
        ("system", "You are an assistant that classifies queries and replies only in one word as either 'general' or 'database'."),
        ("system", "You have to read the entire user input and decide whether it requires a database or not. If you think the user input is asking for price, customer details, assignment, research paper, it is a database query; otherwise, classify it as general."),
        ("user", "{input}")
    ])
    
    # Format the input for classification
    formatted_classify_input = classify_prompt.format(input=user_input)

    # Step 1: Classify the query
    classification_result = llm_classifier.invoke(formatted_classify_input)

    # Step 2: Based on classification, route to the correct LLM
    classification_text = classification_result.content.strip().lower()

    if classification_text == "general":
        # If it's general, use the general LLM to process the query
        general_result = llm_general.invoke(general_prompt.format(input=user_input))
        final_answer = general_result.content.strip()  # Access only the text response
    elif classification_text == "database":
        # Format the user input with the first prompt template
        formatted_input = chat_prompt.format(input=user_input)
    
        # Step 1: Query the database using the first LLM
        result = agent_executor.invoke(formatted_input)
        
        # Check if the result is valid
        if result['output'] == "I don't know." or not result['output']:
            final_answer = "Sorry, I couldn't retrieve the information for your query."
        else:
            # Step 2: Pass the result to the second LLM for elaboration
            elaborated_input = elaboration_prompt.format(input=result['output'])
            elaborated_result = llm_general.invoke(elaborated_input)
            final_answer = elaborated_result.content.strip()  # Access only the text response
    else:
        final_answer = "Sorry, I couldn't classify the query properly."

    return final_answer

# Function to display database information in the sidebar
def show_database_info(db_manager):
    if db_manager:
        # Get all tables from the database
        tables = db_manager.get_all_tables()
        if tables:
            st.sidebar.subheader("üìä Available Tables")
            for table in tables:
                st.sidebar.write(f"‚Ä¢ {table}")
                
                # Show table schema in an expander
                with st.sidebar.expander(f"Schema for {table}"):
                    schema = db_manager.get_table_schema(table)
                    if schema:
                        schema_df = pd.DataFrame(schema)
                        st.sidebar.dataframe(schema_df, use_container_width=True)
        else:
            st.sidebar.info("No tables available.")
    else:
        st.sidebar.info("Please check your database credentials.")

# Main application function
def main():
    # Display header image centered above the title
    try:
        col1, col2, col3 = st.columns([1, 2, 1])
        with col2:
            st.image("image.png", use_column_width=True)
    except Exception as e:
        logger.warning(f"Header image could not be displayed: {e}")

    st.markdown(f'<h1 class="main-header">ü§ñ {COMPANY_NAME} AI Assistant</h1>', unsafe_allow_html=True)
    
    # Initialize session state
    initialize_session_state()
    
    # Sidebar for configuration and database info
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        
        # Database connection status
        st.subheader("üîå Database Status")
        if db_manager.test_connection():
            st.success("‚úÖ Connected to MySQL")

            # Show database information
            tables = db_manager.get_all_tables()
            if tables:
                st.subheader("üìä Available Tables")
                for table in tables:
                    st.write(f"‚Ä¢ {table}")
                    
                    # Show table schema on expander
                    with st.expander(f"Schema for {table}"):
                        schema = db_manager.get_table_schema(table)
                        if schema:
                            schema_df = pd.DataFrame(schema)
                            st.dataframe(schema_df, use_container_width=True)
        else:
            st.error("‚ùå Database connection failed")
            st.info("Please check your database credentials in the .env file")
        
        # Configuration section
        st.subheader("üîß Settings")
        if st.button("üîÑ Refresh Connection"):
            db_manager.reconnect_if_needed()
            st.rerun()

        # Clear chat button
        if st.button("üóëÔ∏è Clear Chat"):
            st.session_state.messages = []
            st.session_state.chat_history = []
            st.rerun()
    
    # Main chat interface
    st.markdown('<div class="chat-container">', unsafe_allow_html=True)
    
    # Display chat messages
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
    
    # Chat input
    if prompt := st.chat_input("Ask me anything about the company or request database information..."):
        # Add user message to chat
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)
        
        # Generate and display assistant response
        with st.chat_message("assistant"):
            response = classify_and_process_query(prompt)
            st.markdown(response)
            st.session_state.messages.append({"role": "assistant", "content": response})
    
    st.markdown('</div>', unsafe_allow_html=True)
    
    # Footer
    st.markdown("---")
    st.markdown(f"<p style='text-align: center; color: #666;'>Powered by LangChain & OpenAI | {COMPANY_NAME}</p>", unsafe_allow_html=True)

if __name__ == "__main__":
    main()
